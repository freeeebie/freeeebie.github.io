<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Log</title><link href="https://freeeebie.github.io/" rel="alternate"></link><link href="https://freeeebie.github.io/feeds/all.atom.xml" rel="self"></link><id>https://freeeebie.github.io/</id><updated>2016-10-02T14:39:10+09:00</updated><entry><title>"BST node count"</title><link href="https://freeeebie.github.io/bst-node-count.html" rel="alternate"></link><published>2016-10-02T14:39:10+09:00</published><updated>2016-10-02T14:39:10+09:00</updated><author><name>freeeebie</name></author><id>tag:freeeebie.github.io,2016-10-02:bst-node-count.html</id><summary type="html">&lt;h1&gt;BST 에서 node 갯수 세기&lt;/h1&gt;
&lt;p&gt;left/right sub tree 의 children 숫자가 미리 주어졌을 때, 입력된 node 보다 큰 수 or 작은 수의 갯수 구하기  &lt;/p&gt;
&lt;h2&gt;입력 node 보다 작은 숫자 구하기&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;start root  &lt;/li&gt;
&lt;li&gt;만약 입력 데이터보다 해당 노드의 숫자가 크다면(if input &amp;lt; node.value), 왼쪽 노드로 이동  &lt;/li&gt;
&lt;li&gt;만약 입력 데이터보다 해당 노드의 숫자가 작다면(if input &amp;gt;= node.value), count 변수에 해당 node 의 left sub tree 의 node 숫자 + 1(해당 node) 을 더하고, 오른쪽으로 이동.  &lt;/li&gt;
&lt;li&gt;이동한 node 가 null 인 경우까지 반복  &lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;count_less&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;count_less&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;leftchildren&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;count_less&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;leftchildren&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;입력 node 보다 큰 숫자 구하기&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;start root &lt;/li&gt;
&lt;li&gt;만약 입력 데이터보다 해당 노드의 숫자가 크다면(if input &amp;lt; node.value), count 변수에 해당 node 의 right sub tree 의 node 숫자 + 1(해당 node) 을 더하고, 왼쪽 자식으로 이동. &lt;/li&gt;
&lt;li&gt;만약 입력 데이터보다 해당 노드의 숫자가 작다면(if input &amp;gt;= node.value), 오른쪽 자식으로 이동 &lt;/li&gt;
&lt;li&gt;이동한 node 가 null 인 경우까지 반복 &lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;count_more&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;count_more&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rightchildren&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;count_more&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rightchildren&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;전체 코드&lt;br /&gt;
https://github.com/freeeebie/algorithm-study/blob/master/tree/count_less_greater_nodes.py&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;reference&lt;br /&gt;
https://www.careercup.com/question?id=5165570324430848&lt;/p&gt;</summary><category term="algorithm"></category></entry><entry><title>"Keyboard Shortcuts for Bash"</title><link href="https://freeeebie.github.io/keyboard-shortcuts-for-bash.html" rel="alternate"></link><published>2016-10-02T14:33:33+09:00</published><updated>2016-10-02T14:33:33+09:00</updated><author><name>freeeebie</name></author><id>tag:freeeebie.github.io,2016-10-02:keyboard-shortcuts-for-bash.html</id><summary type="html">&lt;h1&gt;Bash shell 단축키&lt;/h1&gt;
&lt;p&gt;http://www.howtogeek.com/howto/ubuntu/keyboard-shortcuts-for-bash-command-shell-for-ubuntu-debian-suse-redhat-linux-etc/ 에서 발췌함  &lt;/p&gt;
&lt;p&gt;Ctrl + A    Go to the beginning of the line you are currently typing on&lt;br /&gt;
Ctrl + E    Go to the end of the line you are currently typing on&lt;br /&gt;
Ctrl + L                Clears the Screen, similar to the clear command&lt;br /&gt;
Ctrl + U    Clears the line before the cursor position. If you are at the end of the line, clears the entire line.&lt;br /&gt;
Ctrl + H    Same as backspace&lt;br /&gt;
Ctrl + R    Let’s you search through previously used commands&lt;br /&gt;
Ctrl + C    Kill whatever you are running&lt;br /&gt;
Ctrl + D    Exit the current shell&lt;br /&gt;
Ctrl + Z    Puts whatever you are running into a suspended   background process. fg restores it.&lt;br /&gt;
Ctrl + W    Delete the word before the cursor&lt;br /&gt;
Ctrl + K    Clear the line after the cursor&lt;br /&gt;
Ctrl + T    Swap the last two characters before the cursor&lt;br /&gt;
Esc + T Swap the last two words before the cursor&lt;br /&gt;
Alt + F Move cursor forward one word on the current line&lt;br /&gt;
Alt + B Move cursor backward one word on the current line&lt;br /&gt;
Tab Auto-complete files and folder names  &lt;/p&gt;
&lt;hr /&gt;</summary><category term="info"></category></entry><entry><title>"Linear Regression"</title><link href="https://freeeebie.github.io/linear-regression.html" rel="alternate"></link><published>2016-10-01T22:18:30+09:00</published><updated>2016-10-01T22:18:30+09:00</updated><author><name>freeeebie</name></author><id>tag:freeeebie.github.io,2016-10-01:linear-regression.html</id><summary type="html">&lt;h1&gt;다항식 회귀&lt;/h1&gt;
&lt;p&gt;$$ g(x_i | w_k, \cdots, w_1, w_0) = w_k(x_i)^k + \cdots + w_2(x_i)^2 + w_1(x_i) + w_0$$&lt;br /&gt;
$ \overrightarrow{z_i}= [x_i \:\:(x_i)^2 \:\cdots\: (x_i)^k] $ 를 갖는 다변의 선형 회귀라고 여기고 푼다.  &lt;/p&gt;
&lt;h1&gt;Model Selection&lt;/h1&gt;
&lt;p&gt;정확도를 어떻게 측정. 최대로 잘 맞는지  &lt;/p&gt;
&lt;h1&gt;overfitting&lt;/h1&gt;
&lt;p&gt;모델에 비해 data 가 너무 적어 noise 까지 fitting 해버리는 현상  &lt;/p&gt;
&lt;h1&gt;알고리즘 정확도 측정&lt;/h1&gt;
&lt;p&gt;학습에 동원되지 않은 데이터로 에러 측정&lt;br /&gt;
K-folder Cross Validation (CV)  &lt;/p&gt;
&lt;h2&gt;항상 지켜야 될 원칙&lt;/h2&gt;
&lt;p&gt;훈련에 쓰지 않는 데이터로 에러 측정 &lt;/p&gt;
&lt;h2&gt;Dimension의 저주&lt;/h2&gt;
&lt;p&gt;각 데이터가 10개의 속성이 있을 때 $10^{10} \:?? $&lt;/p&gt;
&lt;h1&gt;Feature mapping&lt;/h1&gt;
&lt;p&gt;$$ \overrightarrow{z} = \phi(\overrightarrow{x}) $$&lt;br /&gt;
$$ \frac{1}{wt} = \phi(wt) \Rightarrow mpg = w_0 + w_1 \frac{1}{wt}$$  &lt;/p&gt;</summary><category term="'Machine&amp;nbsp"></category><category term="Learning'"></category></entry><entry><title>"MLE"</title><link href="https://freeeebie.github.io/mle.html" rel="alternate"></link><published>2016-09-18T15:51:26+09:00</published><updated>2016-09-18T15:51:26+09:00</updated><author><name>freeeebie</name></author><id>tag:freeeebie.github.io,2016-09-18:mle.html</id><summary type="html">&lt;h1&gt;최우도 추정&lt;/h1&gt;
&lt;p&gt;Maximum likelihood estimation&lt;br /&gt;
데이터들이 어떤 확률 분포에 가까운지 추정하는 방법 중 하나.  &lt;/p&gt;
&lt;p&gt;$$D = {x_1, x_2,\cdots,x_N}$$
일 때, 
데이터 집합의 정규분포의 위치와 모양을 결정 짓는 매개 변수 $\mu$ 와 $\sigma^2$ 를 구한다면,&lt;br /&gt;
우도  $L(D, \mu, \sigma)$&lt;br /&gt;
여기에 로그를 취하면, $\mathcal{L}(D, \mu, \sigma)$  &lt;/p&gt;
&lt;p&gt;최우도 추정은 우도를 편미분하여 최대값을 구한다.&lt;br /&gt;
$$ \hat\mu = \Sigma_i x^i/N \Leftrightarrow \partial L(D, \mu, \sigma)$$&lt;br /&gt;
$$ \hat\sigma^2 = \Sigma_i (x_i - \hat\mu)^2 / N \Leftrightarrow \partial \mathcal{L}(D, \mu, \sigma) $$  &lt;/p&gt;</summary><category term="math"></category></entry><entry><title>"확률"</title><link href="https://freeeebie.github.io/hwagryul.html" rel="alternate"></link><published>2016-09-17T00:27:19+09:00</published><updated>2016-09-17T00:27:19+09:00</updated><author><name>freeeebie</name></author><id>tag:freeeebie.github.io,2016-09-17:hwagryul.html</id><summary type="html">&lt;h1&gt;확률분포&lt;/h1&gt;
&lt;h2&gt;Random Variable(확률변수)&lt;/h2&gt;
&lt;p&gt;정의  &lt;/p&gt;
&lt;p&gt;$$ X:\Omega\Rightarrow R $$&lt;br /&gt;
X: 함수&lt;/p&gt;
&lt;p&gt;이산확률변수&lt;br /&gt;
$P(X=k)= P({w:X(w)=k})$&lt;/p&gt;
&lt;h2&gt;Joint probability(결합확률)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;확률질량함수&lt;br /&gt;
이산데이터에 대하여 누적 확률  &lt;/li&gt;
&lt;li&gt;누적분포함수 (CDF)&lt;br /&gt;
    확률값을 적분한 것. 1에 수렴 &lt;/li&gt;
&lt;li&gt;확률밀도함수&lt;br /&gt;
누적분포를 미분한 것 &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Maginary probability(주변확률)&lt;/h2&gt;
&lt;p&gt;두 변수중 한가지 확률변수 계산&lt;br /&gt;
왜  maginary 인가?? table 로 표현하면 주분에 위치하므로, &lt;/p&gt;
&lt;h2&gt;Conditional PMF (조건부 확률)&lt;/h2&gt;
&lt;p&gt;$$P_{Y|X} (y|x) =   $$
$${P_{XY}(x,y)} \over {P_X(x)} $$&lt;/p&gt;
&lt;p&gt;random variable X의 값이 x라고 알려져 있을 때, Y가 y일 확률&lt;/p&gt;
&lt;h3&gt;Product rule&lt;/h3&gt;
&lt;p&gt;conditional PMF 의 정의로 구함&lt;br /&gt;
$$P_{Y|X} (y|x) = P(y|x)P(x) = P(x|y)P(y)$$  &lt;/p&gt;
&lt;h2&gt;대표적 연속 확률 분포&lt;/h2&gt;
&lt;h3&gt;정규분포&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;가우스 분포 &lt;/li&gt;
&lt;li&gt;$ X \thicksim N(\mu, \sigma^2) $&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PDF&lt;br /&gt;
$$ f_X(x) = \frac {1}{\sqrt{2\pi\sigma^2}}exp[-\frac{(x-\mu)^2}{2\sigma^2}]  $$  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$E[x] = \mu$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;$var[x] = \sigma^2$&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;대표적 이산 확률 분포&lt;/h2&gt;
&lt;h3&gt;베르누이 분포&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;PMF&lt;br /&gt;
$$ P_X(x) = 
\left{ \begin{array}{rcl}
         p &amp;amp; \mbox{if}
         &amp;amp; x = 1 \ 1-p &amp;amp; \mbox{if} &amp;amp; x = 0
                \end{array}\right.
$$  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$E[X] = P $&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;$Var[X] = P(1-P) $ &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;이항분포&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Binomial Distribution &lt;/li&gt;
&lt;li&gt;$ X \thicksim Binom(n,p) $&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PMF&lt;br /&gt;
$$ P_X(X) = 
\left( \begin{array}{c} n \ x \end{array} \right) p^x(1-p)^{n-x}
$$  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$E[x] = \Sigma E[x_i] = np$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;$Var[x] = \Sigma Var[X_i] = np(1-p)$&lt;/li&gt;
&lt;/ul&gt;</summary><category term='"Math"'></category></entry><entry><title>"MFCC와 GMM 사용하여 음원 분류"</title><link href="https://freeeebie.github.io/mfccwa-gmm-sayonghayeo-eumweon-bunryu.html" rel="alternate"></link><published>2016-09-11T21:49:31+09:00</published><updated>2016-09-11T21:49:31+09:00</updated><author><name>freeeebie</name></author><id>tag:freeeebie.github.io,2016-09-11:mfccwa-gmm-sayonghayeo-eumweon-bunryu.html</id><summary type="html">&lt;h1&gt;Sound 분류&lt;/h1&gt;
&lt;p&gt;MFCC 와 GMM 을 사용하여 음원 파일을 인식하여 분류함  &lt;/p&gt;
&lt;h2&gt;precedure&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;trainging data 의 MFCC 추출  &lt;/li&gt;
&lt;li&gt;각 training data 에 대한 GMM 생성  &lt;/li&gt;
&lt;li&gt;입력 음원에 대하여 MFCC 추출  &lt;/li&gt;
&lt;li&gt;각 GMM 에 대하여 확률을 계산하여 best 한 GMM 모델을 선택  &lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;GMM&lt;/h2&gt;
&lt;p&gt;clustering 기법&lt;br /&gt;
EM algorithm 사용  &lt;/p&gt;</summary></entry><entry><title>"MFCC"</title><link href="https://freeeebie.github.io/mfcc.html" rel="alternate"></link><published>2016-09-11T19:16:07+09:00</published><updated>2016-09-11T19:16:07+09:00</updated><author><name>freeeebie</name></author><id>tag:freeeebie.github.io,2016-09-11:mfcc.html</id><summary type="html">&lt;p&gt;음성 데이터의 특징 추출&lt;br /&gt;
성대의 떨림은 고유함.성도를 system H 라고 가정하여&lt;br /&gt;
이 시스템 H의 특징을 찾음.  &lt;/p&gt;
&lt;p&gt;1 step&lt;br /&gt;
시그널을 일정 frame 단위로 나눔.&lt;br /&gt;
windowing 실행&lt;br /&gt;
2 step&lt;br /&gt;
해당 frame에 Fourier Transform을 실행하여 power spectrum 을 구함.&lt;br /&gt;
3 step&lt;br /&gt;
mel filter bank 적용&lt;br /&gt;
4 step&lt;br /&gt;
log 적용&lt;br /&gt;
5 step&lt;br /&gt;
DCT 실행&lt;br /&gt;
6 step&lt;br /&gt;
liftering 실행  &lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;reference&lt;br /&gt;
https://en.wikipedia.org/wiki/Mel-frequency_cepstrum&lt;br /&gt;
http://practicalcryptography.com/miscellaneous/machine-learning/guide-mel-frequency-cepstral-coefficients-mfccs/  &lt;/p&gt;</summary><category term='"Machine&amp;nbsp'></category><category term='Learning"'></category></entry><entry><title>first_post</title><link href="https://freeeebie.github.io/first_post.html" rel="alternate"></link><published>2014-12-13T18:32:00+09:00</published><updated>2014-12-13T18:32:00+09:00</updated><author><name>freeeebie</name></author><id>tag:freeeebie.github.io,2014-12-13:first_post.html</id><summary type="html">&lt;p&gt;Hello World from Pelican!&lt;/p&gt;
</summary></entry></feed>